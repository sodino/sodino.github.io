<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><script data-ad-client="ca-pub-9442633619132398" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script data-ad-client="ca-pub-9442633619132398" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Sodino的个人博客"><title>【C/C++】string操作方法汇总 | Sodino's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【C/C++】string操作方法汇总</h1><a id="logo" href="/.">Sodino's Blog</a><p class="description">见多食广 与食巨近</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">【C/C++】string操作方法汇总</h1><div class="post-meta">Feb 4, 2015<span> | </span><span class="category"><a href="/categories/C-C/">C/C++</a></span></div><div class="post-content"><p>本文提供【C/C++】string操作方法汇总如下：</p>
<ul>
<li>判断内容是否相同</li>
<li>字符串复制</li>
<li>字符串拼接</li>
<li>字符串拼接单个char</li>
<li>字符串类别检查</li>
<li>字符串子串截取 (substring)</li>
<li>字符串界位符切割 (strtok   strtok_r)</li>
</ul>
<p>#判断内容是否相同</p>
<p><code>#include &lt;string.h&gt;</code></p>
<ul>
<li><p>int strcmp(const char *s1, const char *s2);  <strong>Thread-Safe</strong><br>int strncmp(const char *s1, const char *s2, size_t n);  <strong>Thread-Safe</strong><br>对s1与s2进行的比较。大小写敏感。<br>return ==0, s1 == s2;<br>return &gt;0,  s1 &gt; s2;<br>return &lt;0,  s1 &lt; s2;</p>
</li>
<li><p>int memcmp(const void *s1, const void *s2, size_t n); <strong>Thread-safe</strong><br>注意，这里的参数是<strong>void</strong>而不是普通的char *，所以memcmp可以对更广泛的对象进行对比，如字符数组，整型，类，结构体等。比较的内容为第三个参数所限定的长度范围内。</p>
</li>
<li><p>int strcoll(const char *s1, const char *s2);<br>比较字符串s1和s2。功能和strcmp类似,用法也一样.<br>特别注意:strcoll()会依环境变量LC_COLLATE所指定的文字排列次序来比较s1和s2字符串。<br>strcmp是根据<strong>ASCII</strong>来比较2个字符串的.若LC_COLLATE为”POSIX”或”C”，则strcoll()与strcmp()作用完全相同。</p>
</li>
</ul>
<p><code>#include &lt;strings.h&gt;</code></p>
<ul>
<li><p>int strcasecmp(const char *s1, const char *s2);<br>int strncasecmp(const char *s1, const char *s2, size_t n);<br>对s1与s2进行大小写无关的比较。<br>return ==0, s1 == s2;<br>return &gt;0,  s1 &gt; s2;<br>return &lt;0,  s1 &lt; s2;</p>
</li>
<li><p>int <del>bcmp</del>(const void *s1, const void *s2, size_t n)  <strong>Thread-Safe</strong><br>已废弃的方法，不推荐使用。推荐使用memcmp代替。</p>
</li>
</ul>
<p>#字符串复制<br><code>#include &lt;string.h&gt;</code></p>
<ul>
<li>char *strcpy(char *dest, const char *src);  <strong>Thread-Safe</strong><br>char *strncpy(char *dest, const char *src, size_t n);  <strong>Thread-Safe</strong><br>将src指向的字符串(全部或指定的n个字符)复制到dest中，其中dest与src指向的内存空间不能重叠。要保证dest有足够的空间能够容纳src中的内容，否则<strong>may make the impossible possible.</strong><br>对于strncpy()只负责拷贝指定长度的字符，拷贝完并不会在字符的结尾加上字符串终止符。所以见下面的示例代码中会打印出”c.st strcpy()”.对于n其长度最大值就为dest_length -1，因为最后一个位置还要放一个字符串终止符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * strA = <span class="string">"Test strcpy()"</span>; <span class="comment">// 对于下面的strDest中长度最小要13 + 1=14。</span></span><br><span class="line"><span class="keyword">char</span> strDest[<span class="number">100</span>]; <span class="comment">// 声明一个数组，空间对于将要复制的字符串来说要足够大。</span></span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">strcpy</span> = <span class="built_in">strcpy</span>(strDest, strA); <span class="comment">// 执行复制。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s \n"</span>, <span class="built_in">strcpy</span>); <span class="comment">// 打印出：Test strcpy()</span></span><br><span class="line"><span class="built_in">strcpy</span> = <span class="built_in">strncpy</span>(strDest, <span class="string">"c.code"</span>, <span class="number">2</span>); <span class="comment">// 执行指定长度的字符串内容。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s \n"</span>, <span class="built_in">strcpy</span>); <span class="comment">// 打印出：c.st strcpy()</span></span><br></pre></td></tr></table></figure>

<p>strncpy()如果src比较小，而指定的n比较大时，则strncpy会把多出来的长度用/0填充，这就引出一个效率上不高的问题：如下面的代码中strncpy会填写99个char，而不止是”ab”本身。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> strDest[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">strncpy</span>(strDest, <span class="string">"ab"</span>, <span class="number">99</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>void *memcpy(void *dest, const void *src, size_t n);<br>用法同strncpy()，但注意到这是纯内存拷贝操作，可以对更广泛的对象进行对比，如字符数组，整型，类，结构体等。</p>
</li>
<li><p>size_t strlcpy(char * restrict dst, const char * restrict src, size_t size);<br>strlcpy()是为替代strncpy()而实现的更简易、更安全、更不容易出错的字符串拷贝方式。<br>使用时仅需如下例子在size参数中传入sizeof(dst)即可不用考虑执行结果中是否包含字符串终止符的问题（自动给加上了）。<br>strlcpy()仅仅会从src中拷贝最多size -1个字符，并在dest最后添加上字符串终止符。<br>strlcpy()的返回值是src的长度，所以一旦结果为len &gt; sizeof(buf)，则表示拷贝的结果把src截断了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *src, *p, buf[BUFSIZ];</span><br><span class="line"><span class="keyword">int</span> len = strlcpy(buf, src, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="keyword">sizeof</span>(buf))｛</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s \n"</span>, <span class="string">"string src is truncated."</span>);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>#字符串拼接<br><code>#include &lt;string.h&gt;</code></p>
<ul>
<li><p>char *strcat(char *dest, const char *src);  <strong>Thread-Safe</strong><br>char *strncat(char *dest, const char *src, size_t n);  <strong>Thread-Safe</strong><br>string concatenate<br>字符串拼接同上面的复制，都要求dest有足够的空间，且dest和src所指向的空间不能重叠。<br>dest的空间长度最小值为 strlen(dest) + n + 1。其中n表示strlen(src)或指定要拼接的长度值n，最后一个1表示字符串终止符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个数组，空间对于将要复制和拼接的字符串来说要足够大。</span></span><br><span class="line"><span class="comment">// 6是最小值， 6 = strlen(strA) + 2(strcat) + 1(\0)</span></span><br><span class="line"><span class="keyword">char</span> strDest[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">char</span> * strA = <span class="string">"abc"</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(strDest, strA);</span><br><span class="line"><span class="built_in">strncat</span>(strDest, <span class="string">"123"</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s \n"</span>, strDest); <span class="comment">// 打印出：abc12</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>size_t strlcat(char * restrict dst, const char * restrict src, size_t size);<br>同strlcpy()，是保证进行字符串拼接时以字符串终止符结尾。第三个参数size应传入dst的长度。<br>在如下代码中，很明显dest的空间是不足以拼接”123456789”的，所以最后的拼接结果是“12345”+1个字符串终止符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> strDest[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">char</span> * strA = <span class="string">"123456789"</span>;</span><br><span class="line"><span class="keyword">int</span> result = strlcat(strDest, strA, <span class="keyword">sizeof</span>(strDest));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strDest); <span class="comment">// 打印出“12345”</span></span><br><span class="line"><span class="keyword">if</span> (result)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s be truncated.\n"</span>, strA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>#字符串拼接单个char<br>c中没有现成的函数可以拼接单个char，这里需要用到指针进行赋值，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> dest[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">// 对dest赋值</span></span><br><span class="line"><span class="built_in">strcpy</span>(dest, str);</span><br><span class="line"><span class="keyword">char</span> * pDest;</span><br><span class="line">pDest = dest + <span class="built_in">strlen</span>(dest);</span><br><span class="line"><span class="comment">// 拼接单个字符串</span></span><br><span class="line">*pDest++ = <span class="string">'1'</span>;</span><br><span class="line">*pDest++ = <span class="number">0</span>; <span class="comment">// 字符串终止符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出：abc1 5 4 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s %lu %lu \n"</span>, dest, <span class="keyword">sizeof</span>(dest), <span class="built_in">strlen</span>(dest));</span><br></pre></td></tr></table></figure>

<p>#字符串长度<br>之所以把<code>字符串长度</code>放在<code>字符串拼接</code>之后，是为了更方便讲述理解。<br><code>#include &lt;string.h&gt;</code></p>
<ul>
<li>size_t strlen(const char *s);<br>strlen()直接计算参数<code>s</code>中字符的个数，直至碰到字符串终止符<code>\0</code>时停止计算。所以在<code>字符串拼接单个char</code>中，strlen(dest)返回结果是4。<br>但如果把代码稍作修改成如下，则strlen(dest)返回的结果可就不一定了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> dest[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">// 对dest赋值</span></span><br><span class="line"><span class="built_in">strcpy</span>(dest, str);</span><br><span class="line"><span class="keyword">char</span> * pDest;</span><br><span class="line">pDest = dest + <span class="built_in">strlen</span>(dest);</span><br><span class="line"><span class="comment">// 拼接单个字符串</span></span><br><span class="line">*pDest++ = <span class="string">'1'</span>;</span><br><span class="line">*pDest++ = <span class="string">'2'</span>; <span class="comment">// 改动点：不以字符串终止符结尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出：abc12\300\370\277_\377 5 11 内容是不固定的</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s %lu %lu \n"</span>, dest, <span class="keyword">sizeof</span>(dest), <span class="built_in">strlen</span>(dest));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>可以看到，strlen()返回的长度已经超出了dest可容纳的最大值。所以该函数返回的结果存在一定的溢出风险。<br>如何解决该问题？可以使用下面的函数。</p>
<ul>
<li>size_t strnlen(const char *s, size_t maxlen);<br>strnlen()的第2个参数指定<code>s</code>的最大值，正常情况下和strlen()能力是一致的。区别在于strnlen()返回的最大值最多只能是<code>maxlen</code>。所以如果返回值为参数<code>maxlen</code>时，即可以判断出<code>s</code>是非正常的字符串终止符结尾，需要特别处理。见下示例代码。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n_len = strnlen(dest, <span class="keyword">sizeof</span>(dest));</span><br><span class="line"><span class="keyword">if</span> (n_len &gt;= <span class="keyword">sizeof</span>(dest))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"dest is not NUL-TERMINALED \n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"dest.len=%d \n"</span>, n_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>#字符类别检查<br><code>#include &lt;ctype.h&gt;</code></p>
<ul>
<li>int isalnum(int c);<br>  返回1表示字符<code>c</code>是 大小写字母 或 数字;否则返回0。</li>
<li>int isalpha(int c);<br>  返回1表示字符<code>c</code>是 大小写字母 ;否则返回0。<br>  相当于(isupper(c) || islower(c))。在某些locale设置下，有可能一些非字母字符也返回1。</li>
<li>int isascii(int c);<br>  返回1表示字符<code>c</code>属于 ASCII字符集 ;否则返回0。</li>
<li>int isblank(int c);<br>  返回1表示字符<code>c</code>是 空格 或 Tab符<code>\t</code>；否则返回0。注意有些系统或编辑器下的Tab符是由多个空格组成的，这种情况下返回0。</li>
<li>int iscntrl(int c);<br>  返回1表示字符<code>c</code>是控制制服(c:[0:31…]等等)</li>
<li>int isdigit(int c);<br>  返回1表示字符<code>c</code>属于0～9的数字；否则返回0。</li>
<li>int isgraph(int c);<br>  返回1表示字符<code>c</code>属于印刷可见的字符(不包含空格)；否则返回0。大部分情况下返回结果和iscntrl(c)是相反的。</li>
<li>int islower(int c);<br>  返回1表示是英文字母中的小写字符；否则返回0。</li>
<li>int isprint(int c);<br>  同isgraph(c)，区别在于<code>c</code>是空格时也返回1。</li>
<li>int ispunct(int c);<br>  返回1表示排除了空格及英文字母数字的可打印字符集；否则返回0。</li>
<li>int isspace(int c);<br>  返回1时表示<code>c</code>属于 空格、\f、换行符‘\n’、回车’\r’、水平Tab<code>\t</code>、垂直Tab<code>\v</code>；否则返回0。</li>
<li>int isupper(int c);<br>  返回1时表示<code>c</code>羽毛球英文字母中的大写字母。</li>
<li>int isxdigit(int c);<br>  返回1时表示<code>c</code>属于数字十六进制表示形式中的字符(0<del>9、a</del>f、A~F);否则返回0。</li>
</ul>
<p>#字符串子串截取<br>c的类库中目前没有找到现成的字符串子串截取方法。<br>如果是想截取指定字符串从起始位置开始的前n个字符，可以使用<code>strncpy</code>或<code>memcpy</code>代替。<br>但如果是想字符串截取从第n个到第n+x个字符的子字符串，得自己实现了。示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">substring</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">const</span> <span class="keyword">int</span> idxStart, <span class="keyword">const</span> <span class="keyword">int</span> idxEnd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(src) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"arg src.length is 0, return."</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idxEnd &gt; <span class="built_in">strlen</span>(src)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"idxEnd=%d &gt; strlen(src)=%lu, return."</span>, idxEnd, <span class="built_in">strlen</span>(src));</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idxStart &gt;= idxEnd) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"idxStart=%d &gt;= idxEnd=%d, return."</span>, idxStart, idxEnd);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 避免直接定义固定长度</span></span><br><span class="line">    <span class="keyword">int</span> length = idxEnd - idxStart + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> sub_length = length;</span><br><span class="line">    <span class="comment">// 使用malloc，避免在函数体结束之后即回回收导致函数返回值无法被使用。</span></span><br><span class="line">    <span class="comment">// 需要使用free()释放；</span></span><br><span class="line">    <span class="keyword">char</span> * pDest = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(sub_length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = idxStart;i &lt; idxEnd;i ++) &#123;</span><br><span class="line"><span class="comment">//        printf("src %c \n", *(src+i));</span></span><br><span class="line">        *(pDest + (i-idxStart)) = *(src+i);</span><br><span class="line"><span class="comment">//        printf("dest %c \n", *(pDest + (i-idxStart)));</span></span><br><span class="line">    &#125;</span><br><span class="line">    *(pDest+(idxEnd - idxStart)) = <span class="number">0</span>; <span class="comment">// 添加上字符串终止符</span></span><br><span class="line"><span class="comment">//    printf("pDest=%s %p\n", pDest, pDest);</span></span><br><span class="line">    <span class="keyword">return</span> pDest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * src = <span class="string">"abc123ABC"</span>;</span><br><span class="line">    <span class="keyword">char</span> *dest = substring(src, <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="comment">//打印出"123"</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"substring1=[%s] \n"</span>, dest);</span><br><span class="line">    <span class="comment">// 不要了，回收掉</span></span><br><span class="line">    <span class="built_in">free</span>(dest);</span><br><span class="line">    <span class="comment">// 不需要了之后对指针置空，防止野指针</span></span><br><span class="line">    dest = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s \n"</span>, dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#字符串界位符切割<br><code>#include &lt;string.h&gt;</code></p>
<ul>
<li>char *strtok(char *str, const char *delim);</li>
<li>char *strtok_r(char *str, const char <em>\delim, char \</em>*saveptr);<br>以上两个函数可以将指定的字符串切割成0个或数个非空子串.<br>以上两个函数在第一次调用时，第一个参数<code>str</code>传入待切割的长字符串；在下次循环调用之前需要把<code>str</code>置为NULL。<br>第2个参数<code>delim</code>指定切割关键字符集（所以可以包含多种情况）。<br>函数执行后的返回结果是切割后的子字符串，如果返回为NULL，则表示已经没有目标切割对象了，可以停止循环。<br>以下代码示例strtok()的使用，切割标准为<code>-</code>或<code>:</code>字符：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> * token;</span><br><span class="line">    <span class="keyword">char</span> original[] = <span class="string">"ab-cd;ef-gh"</span>;</span><br><span class="line">    <span class="keyword">char</span> * src = original;</span><br><span class="line">    <span class="keyword">char</span> * delim = <span class="string">";-"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;; i ++) &#123;</span><br><span class="line">        token = strtok(src, delim);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d:%s "</span>, i, token);</span><br><span class="line">        <span class="keyword">if</span> (src != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            src = <span class="literal">NULL</span>; <span class="comment">// 对src置空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 打印出：0:ab 1:cd 2:ef 3:gh</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>对src置空后，循环的调用仍可输出切割的子字符串结果，个人觉得应该是在strtok()方法体内使用了函数内静态参数的原因。</p>
<p>strtok_r():strtok reentrant<br>strtok_r()是可重入版本的strtok()方法。第三个参数<code>saveptr</code>用于指向未进行切割处理的字符串子串。是指向指针的指针。这也是可重入计算的关键。<br>如下示例代码中演示了strtok_r()的可重入计算，即在循环体内再嵌套一个循环用第二种界位符对字符进行二次切割。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str1, *str2, *token, *subtoken;</span><br><span class="line">    <span class="keyword">char</span> *saveptr1, *saveptr2;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s string delim subdelim\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> argv1_len = <span class="built_in">strlen</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">char</span> argv1[argv1_len];</span><br><span class="line">    <span class="built_in">strcpy</span>(argv1, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"argv1=%s \n"</span>, argv1);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  for (j = 1, str1 = argv[1]; ; j++, str1 = NULL) &#123;</span></span><br><span class="line">    <span class="comment">// 这种写法，避免Assigning to 'char *' from 'const char *' discards qualifiers</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>, str1 = argv1; ; j++, str1 = <span class="literal">NULL</span>) &#123;</span><br><span class="line">        token = strtok_r(str1, argv[<span class="number">2</span>], &amp;saveptr1);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: %s  %s\n"</span>, j, token, saveptr1);<span class="comment">// 当saveptr1为null时，则下个循环时strtok_r()返回结果亦为null</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (str2 = token; ; str2 = <span class="literal">NULL</span>) &#123;</span><br><span class="line">            subtoken = strtok_r(str2, argv[<span class="number">3</span>], &amp;saveptr2);</span><br><span class="line">            <span class="keyword">if</span> (subtoken == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" --&gt; %s \n"</span>, subtoken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在命令行工具下执行命令，对长字符进行两次切割，先”-:”后”/“。<br>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sodino:CString sodino$ ./a.out &quot;a-b-cd:ef/hi/jk:///lm://no-p:q&quot; &quot;-:&quot; &quot;/&quot;</span><br><span class="line">argv1=a-b-cd:ef/hi/jk:///lm://no-p:q </span><br><span class="line">1: a  b-cd:ef/hi/jk:///lm://no-p:q</span><br><span class="line"> --&gt; a </span><br><span class="line">2: b  cd:ef/hi/jk:///lm://no-p:q</span><br><span class="line"> --&gt; b </span><br><span class="line">3: cd  ef/hi/jk:///lm://no-p:q</span><br><span class="line"> --&gt; cd </span><br><span class="line">4: ef/hi/jk  ///lm://no-p:q</span><br><span class="line"> --&gt; ef </span><br><span class="line"> --&gt; hi </span><br><span class="line"> --&gt; jk </span><br><span class="line">5: ///lm  //no-p:q</span><br><span class="line"> --&gt; lm </span><br><span class="line">6: //no  p:q</span><br><span class="line"> --&gt; no </span><br><span class="line">7: p  q</span><br><span class="line"> --&gt; p </span><br><span class="line">8: q  (null)</span><br><span class="line"> --&gt; q</span><br></pre></td></tr></table></figure></div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2015/03/04/mac-take-down/">【Mac】Mac超好用技巧</a><a class="next" href="/2015/02/01/c-printf-desc/">【C/C++】printf()函数用法汇总</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://sodino.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/AndroidStudio/">AndroidStudio</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JNI/">JNI</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LBS/">LBS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Proguard/">Proguard</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React-Native</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/AndroidStudio/" style="font-size: 15px;">AndroidStudio</a> <a href="/tags/Eclipse/" style="font-size: 15px;">Eclipse</a> <a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/object-Object/" style="font-size: 15px;">[object Object]</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/NDK/" style="font-size: 15px;">NDK</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/JNI/" style="font-size: 15px;">JNI</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/LBS/" style="font-size: 15px;">LBS</a> <a href="/tags/JDK/" style="font-size: 15px;">JDK</a> <a href="/tags/Mac/" style="font-size: 15px;">Mac</a> <a href="/tags/React-Native/" style="font-size: 15px;">React-Native</a> <a href="/tags/Proguard/" style="font-size: 15px;">Proguard</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/04/01/react-native-provide-custom-config-4-fresco/">【Android】React-Native为Fresco的初始化提供自定义的Configuration</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/22/dexcount/">【Android】方法数查看工具---DexCount</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/22/retrofit-notes/">【Android】Retrofit 的一些笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/20/android-transparent-statusbar/">【Android】透明状态栏在App中的实现与接口设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/28/android-ripple/">【Android】Ripple使用总结及ClickableSpan的冲突解决</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/14/react-native-es6-Solidot/">【React-Native】开源的入门项目 Solidot</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/01/android-mediaPlayer-2-bugs/">【Android】记录Android MediaPlayer的两个bug及其它特殊表现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/01/android-gradle-change-appName/">【Android】Gadle改变应用名称(appName)的两种方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/01/mongo-background-service/">【Linux】启动mongo db后台服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/yum-uninstall-mongodb/">【Linux】yum卸载mongodb及后续问题的解决</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/sodino" title="CSDN's blog" target="_blank">CSDN's blog</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Sodino's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>