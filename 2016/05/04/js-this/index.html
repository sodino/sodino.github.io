<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Sodino的个人博客"><title>【JavaScript】'this'详解 | Sodino's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【JavaScript】'this'详解</h1><a id="logo" href="/.">Sodino's Blog</a><p class="description">见多食广 与食巨近</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">【JavaScript】'this'详解</h1><div class="post-meta">May 4, 2016<span> | </span><span class="category"><a href="/categories/JavaScript/">JavaScript</a></span></div><div class="post-content"><p>文章结构</p>
<ul>
<li><a href="#normal_this">普通的 this</a></li>
<li><ul>
<li><a href="#constructor_this">构造函数中的 this</a></li>
</ul>
</li>
<li><ul>
<li><a href="#obj_method_this">对象方法中的 this</a></li>
</ul>
</li>
<li><a href="#outter_function_this">外漏函数中的 this</a></li>
<li><a href="#inner_function_this">嵌套函数中的 this</a></li>
<li><a href="#modify_this">篡改函数中的 this</a></li>
<li><a href="#use_strict">严格模式的判断</a></li>
<li><a href="#summary">总结</a></li>
<li><a href="#postscript">后记</a></li>
</ul>
<hr>
<h1 id="普通的-this"><a href="#普通的-this" class="headerlink" title="普通的 this"></a><a name="normal_this">普通的 this</a></h1><ul>
<li><h4 id="构造函数中的-this"><a href="#构造函数中的-this" class="headerlink" title="构造函数中的 this"></a><a name="constructor_this">构造函数中的 this</a></h4></li>
</ul>
<p>使用new操作符调用构造函数生成对象时，构造函数内的this为当前所new出来的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">代码一:</div><div class="line">function Car() &#123;</div><div class="line">    console.log(this);</div><div class="line">&#125;</div><div class="line">new Car();</div></pre></td></tr></table></figure>
<p>输出完整的对象结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Car &#123;&#125;</div></pre></td></tr></table></figure>
<ul>
<li><h4 id="对象方法中的-this"><a href="#对象方法中的-this" class="headerlink" title="对象方法中的 this"></a><a name="obj_method_this">对象方法中的 this</a></h4></li>
</ul>
<p>下面的代码定义了一个对象benz，并调用该对象的printHistory()，由对象benz调用方法体，所以方法体内的this为对象benz本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">代码二:</div><div class="line">var benz = &#123;</div><div class="line">    printHistory : function() &#123;</div><div class="line">        console.log(this);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">benz.printHistory();</div></pre></td></tr></table></figure>
<p>输出完整的类结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; printHistory: [Function] &#125;</div></pre></td></tr></table></figure>
<p>以上两种情况，this的含义都很明确，即当前的对象本身。</p>
<hr>
<h1 id="外漏函数中的-this"><a href="#外漏函数中的-this" class="headerlink" title="外漏函数中的 this"></a><a name="outter_function_this">外漏函数中的 this</a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">代码三:</div><div class="line">var benz = &#123;</div><div class="line">    printHistory : function() &#123;</div><div class="line">        console.log(this);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 将对象中的方法暴露出来成为外漏函数</div><div class="line">var printHistory = benz.printHistory;</div><div class="line">printHistory();</div></pre></td></tr></table></figure>
<p>执行代码后，控制台输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">D:\desk\JavaScript&gt;node this.js</div><div class="line">&#123; DTRACE_NET_SERVER_CONNECTION: [Function], // 打印开始...为全局对象或Window</div><div class="line">  DTRACE_NET_STREAM_END: [Function],</div><div class="line">    ... ... ...</div><div class="line">    ... ... ...</div><div class="line">    ... ... ...</div><div class="line">  COUNTER_HTTP_CLIENT_REQUEST: [Function], // sodino.com</div><div class="line">  COUNTER_HTTP_CLIENT_RESPONSE: [Function],</div><div class="line">  global: [Circular],</div><div class="line">  process:</div><div class="line">   process &#123;</div><div class="line">     title: &apos;管理员: Node.js command prompt - node  this.js&apos;,</div><div class="line">     version: &apos;v5.7.0&apos;,</div><div class="line">     moduleLoadList:    // sodino.com</div><div class="line">      [ &apos;Binding contextify&apos;,</div><div class="line">        &apos;Binding natives&apos;,</div><div class="line">        &apos;NativeModule events&apos;,</div></pre></td></tr></table></figure>
<p>以上代码打印的this直接为控制台全局对象GLOBAL或浏览器Window了。<br>这个现象会让很多人困惑。<br>要理解该现象的原因要从查看调用链去理解：被调用函数是一个对象的属性还是函数自己。<br>如果它被作为属性调用，那么this的值将变成该属性的对象，否则this的值将被默认赋值为控制台全局对象GLOBAL或浏览器的Window了。</p>
<hr>
<h1 id="嵌套函数中的-this"><a href="#嵌套函数中的-this" class="headerlink" title="嵌套函数中的 this"></a><a name="inner_function_this">嵌套函数中的 this</a></h1><p>对 benz::printHistory()中增加一嵌套函数，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">代码四:</div><div class="line">var benz = &#123;</div><div class="line">    printHistory : function() &#123;</div><div class="line">        // print history after AD2000</div><div class="line">        console.log(this); // 这里this是benz本身</div><div class="line"></div><div class="line">        (function()&#123;</div><div class="line">            // print history before AD2000</div><div class="line">            console.log(this); // 这里this是Global或Window</div><div class="line">        &#125;)();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">benz.printHistory();</div></pre></td></tr></table></figure>
<p>控制台输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">D:\desk\JavaScript&gt;node this.js</div><div class="line">&#123; printHistory: [Function] &#125;    // 第一次打印仍为benz本身</div><div class="line">&#123; DTRACE_NET_SERVER_CONNECTION: [Function], // 第二次打印开始...为全局对象或Window</div><div class="line">  DTRACE_NET_STREAM_END: [Function],</div><div class="line">    ... ... ...</div><div class="line">    ... ... ...</div><div class="line">    ... ... ...</div><div class="line">  COUNTER_HTTP_CLIENT_REQUEST: [Function], // sodino.com</div><div class="line">  COUNTER_HTTP_CLIENT_RESPONSE: [Function],</div><div class="line">  global: [Circular],</div><div class="line">  process:</div><div class="line">   process &#123;</div><div class="line">     title: &apos;管理员: Node.js command prompt - node  this.js&apos;,</div><div class="line">     version: &apos;v5.7.0&apos;,</div><div class="line">     moduleLoadList:    // sodino.com</div><div class="line">      [ &apos;Binding contextify&apos;,</div><div class="line">        &apos;Binding natives&apos;,</div><div class="line">        &apos;NativeModule events&apos;,</div></pre></td></tr></table></figure>
<p>以上代码，第一次打印this，仍是benz本身；但在嵌套函数中打印的this则为控制台全局对象或浏览器的Window了。<br>this不同于普通的对象声明，this的值无法在被嵌套的函数作用域中保持不变，这是JavaScript的缺陷。<br>但回想上文中“被调用函数是一个对象的属性还是函数自己”这一判断标准，嵌套函数并不是benz中的属性，所以this值为控制台全局对象或浏览器的Window也可以顺利理解了。</p>
<p>如果想在嵌套函数使用到上下文的this，有两种办法：<br>方法一：新声明一个变量持有上下文this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">代码五:</div><div class="line">var benz = &#123;</div><div class="line">    printHistory : function() &#123;</div><div class="line">        // print something after AD2000</div><div class="line">        console.log(this);</div><div class="line">        var self = this;  // 声明新变量持有this</div><div class="line"></div><div class="line">        (function()&#123;</div><div class="line">            // print something before AD2000</div><div class="line">            console.log(self);  // 引用上下文this</div><div class="line">        &#125;)();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">benz.printHistory();</div></pre></td></tr></table></figure>
<p>该段代码执行的控制台输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">D:\desk\JavaScript&gt;node this.js</div><div class="line">&#123; printHistory: [Function] &#125;</div><div class="line">&#123; printHistory: [Function] &#125;</div></pre></td></tr></table></figure>
<p>方法二：使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">Function.prototype.bind(thisArg[, arg1[, arg2[, …]]])</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">代码六:</div><div class="line">var benz = &#123;</div><div class="line">    printHistory : function() &#123;</div><div class="line">        // print something after AD2000</div><div class="line">        console.log(this);</div><div class="line"></div><div class="line"></div><div class="line">        (function()&#123;</div><div class="line">            // print something before AD2000</div><div class="line">            console.log(this);</div><div class="line">        &#125;).bind(this)();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">benz.printHistory();</div></pre></td></tr></table></figure>
<p>Function.prototype.bind()方法会返回一个新的函数体，新函数体的功能和原先函数保持一致，只是在新函数体内this的值为bind()方法参数中第一个参数的值。<br>bind()方法返回新函数后，就通过“bind(this) <strong>()</strong>“直接被执行了。<br>由此，为控制台的两处打印信息都是benz本身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">D:\desk\JavaScript&gt;node this.js</div><div class="line">&#123; printHistory: [Function] &#125;</div><div class="line">&#123; printHistory: [Function] &#125;</div></pre></td></tr></table></figure>
<p>在维持上下文环境一致的实现选择上，bind()是更受推荐的方法。</p>
<p>由此，也引出下面的内容：如何篡改函数体中的this.</p>
<hr>
<h1 id="篡改函数中的-this"><a href="#篡改函数中的-this" class="headerlink" title="篡改函数中的 this"></a><a name="modify_this">篡改函数中的 this</a></h1><p>上文已经通过Function.prototype.bind()方法将嵌套函数中this的值指定为bind()的第一个参数值。JavaScript还有另外两个方法也可以实现同样的效果。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="external">Function.prototype.apply(thisArg, [argsArray])</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="external">Function.prototype.call(thisArg[, arg1[, arg2[, …]]])</a></p>
<p>apply()和call()方法的功能是相同的，都是调用一个对象的一个方法，并用第一个参数的值替换该方法原来的对象，即替换掉方法中的this的值。<br>apply()与call()方法的区别只是所接收的方法参数不同，除了第一个参数外，apply()接收的第二个参数为数组，即允许将多个参数合并为一个数组传入，而call()只能从第二个参数起逐个一一传入。</p>
<p>通过对上文中代码二的修改，使用apply()或call()来篡改函数中this的实现如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">代码七：</div><div class="line">var benz = &#123;</div><div class="line">    printHistory : function() &#123;</div><div class="line">        console.log(this);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var printHistory = benz.printHistory;</div><div class="line"></div><div class="line">printHistory.apply(benz);  // 指定了printHistory的上下文环境仍为benz</div><div class="line">printHistory.call(benz);     // 当没有额外的参数时，apply()和call()的用法是相同的</div></pre></td></tr></table></figure>
<p>以上代码的控制台输出都打印出了benz本身，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">D:\desk\JavaScript&gt;node this.js</div><div class="line">&#123; printHistory: [Function] &#125;</div><div class="line">&#123; printHistory: [Function] &#125;</div></pre></td></tr></table></figure>
<p>另外，以下的几个方法同样也可以篡改callback函数中的this值，只是能用性没有apply()/call()/bind()强。<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find" target="_blank" rel="external">Array.prototype.find(callback[, thisArg])</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank" rel="external">Array.prototype.every(callback[, thisArg])</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="external">Array.prototype.forEach(callback[, thisArg])</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank" rel="external">Array.prototype.some(callback[, thisArg])</a></p>
<hr>
<h1 id="严格模式的判断"><a href="#严格模式的判断" class="headerlink" title="严格模式的判断"></a><a name="use_strict">严格模式的判断</a></h1><p>根据ECMAScript 3和非严格的ECMAScript 5对函数调用的规定，调用上下文(this的值)是全局对象。<br>在严格模式下，调用上下文(this的值)则是undefined。<br>所以”this“可以用来判断当前是否是严格模式。方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">代码八:</div><div class="line"></div><div class="line">&apos;use strict&apos;</div><div class="line">// &apos;use strict&apos;启用了严格模式，可以注释掉取消该模式</div><div class="line">var isStrict = (function()&#123;</div><div class="line">    return !this;</div><div class="line">&#125;());</div><div class="line"></div><div class="line">console.log(&apos;isStrict=&apos; + isStrict);</div></pre></td></tr></table></figure>
<p>以上代码在控制台输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">D:\desk\JavaScript&gt;node this.js</div><div class="line">isStrict=true</div></pre></td></tr></table></figure>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a name="summary">总结</a></h1><p>函数体内this就只有两个值，对象本身或运行时环境的全局对象。<br>在非严格模式下，当在Node.js控制台时，全局对象值为 GLOBAL ；当在HTML浏览器运行时，全局对象值为Window。<br>在严格模式下，全局对象是undefined。</p>
<hr>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a><a name="postscript">后记</a></h1><p>注意”总结“里这一句”函数体内this就只有两个值“特意说明了是在”函数体内“。那在函数体外呢？<br>sodino做了下测试，在不同的运行时环境中，函数体外this的值根据运行时环境而有所不同。</p>
<p>直接运行代码九中这一句打印语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">代码九：</div><div class="line">console.log(this);</div></pre></td></tr></table></figure>
<p>在Node.js控制台运行时，this是个<code>{}</code>空对象，如下图：<br><img src="http://ww4.sinaimg.cn/mw1024/e3dc9ceagw1f3jowlp35hj20b207x3zr.jpg" alt="node.js"></p>
<p>在Chrome浏览器中，this是Window。如下图：<br><img src="http://ww4.sinaimg.cn/mw1024/e3dc9ceagw1f3jowlny6yj20c609gmz8.jpg" alt="Window"></p>
<hr>
<p><a href="http://sodino.com/about/">About Sodino</a></p>
</div><div class="tags"><a href="/tags/JavaScript/">JavaScript</a></div><div class="post-nav"><a class="pre" href="/2016/05/05/js-prototype-in-constructor/">【JavaScript】构造函数中定义prototype的异常现象及研究</a><a class="next" href="/2016/04/28/6-months-of-rest/">【Blog】6个月了...时间好快，时间也好慢.</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://sodino.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/AndroidStudio/">AndroidStudio</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JNI/">JNI</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LBS/">LBS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Proguard/">Proguard</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React-Native</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/AndroidStudio/" style="font-size: 15px;">AndroidStudio</a> <a href="/tags/Eclipse/" style="font-size: 15px;">Eclipse</a> <a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/object-Object/" style="font-size: 15px;">[object Object]</a> <a href="/tags/NDK/" style="font-size: 15px;">NDK</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/JNI/" style="font-size: 15px;">JNI</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/LBS/" style="font-size: 15px;">LBS</a> <a href="/tags/JDK/" style="font-size: 15px;">JDK</a> <a href="/tags/Mac/" style="font-size: 15px;">Mac</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Proguard/" style="font-size: 15px;">Proguard</a> <a href="/tags/React-Native/" style="font-size: 15px;">React-Native</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/04/01/react-native-provide-custom-config-4-fresco/">【Android】React-Native为Fresco的初始化提供自定义的Configuration</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/22/dexcount/">【Android】方法数查看工具---DexCount</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/22/retrofit-notes/">【Android】Retrofit 的一些笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/20/android-transparent-statusbar/">【Android】透明状态栏在App中的实现与接口设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/28/android-ripple/">【Android】Ripple使用总结及ClickableSpan的冲突解决</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/14/react-native-es6-Solidot/">【React-Native】开源的入门项目 Solidot</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/01/android-mediaPlayer-2-bugs/">【Android】记录Android MediaPlayer的两个bug及其它特殊表现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/01/android-gradle-change-appName/">【Android】Gadle改变应用名称(appName)的两种方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/01/mongo-background-service/">【Linux】启动mongo db后台服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/yum-uninstall-mongodb/">【Linux】yum卸载mongodb及后续问题的解决</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/sodino" title="CSDN's blog" target="_blank">CSDN's blog</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Sodino's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>